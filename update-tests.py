#!/usr/bin/env python3
import argparse
import tempfile
import subprocess
import os

SKIP_LINE = 'if (builtin.zig_backend == .stage2_spirv64) return error.SkipZigTest;'
COMMENT = ' // generated by spirv update-test.py'

ap = argparse.ArgumentParser('script to update passing Zig tests')
ap.add_argument('compiler', type=str, help='Path to Zig compiler')
ap.add_argument('test', type=str, help='Path to file to test')
ap.add_argument('--todo', default=False, action='store_true', help='Print the number of tests that still need to be done')
ap.add_argument('--recheck', default=False, action='store_true', help='Re-check all tests')

args = ap.parse_args()

basedir = os.path.abspath(os.path.dirname(__file__))

def scan_todo(path):
    with open(path, 'r') as f:
        test = f.readlines()
    total = 0
    for line in test:
        if args.recheck:
            if line.startswith('test'):
                total += 1
        elif SKIP_LINE in line and 'flaky' not in line:
            total += 1
    return total

def update_test(tmpdir, path, start_test, total):
    with open(path, 'r') as f:
        test = f.readlines()

    # First ensure a return error.SkipZigTest for ALL functions. This allows us to
    # re-check, and saves on some compile times in some cases.
    new_test = []
    test_index = None
    last_skip_check = None
    seen_other = False
    for line in test:
        new_test.append(line)
        if line.startswith('test'):
            if test_index is not None and not seen_skip:
                # No skip seen, so insert one
                if last_skip_check is not None:
                    new_test.insert(last_skip_check, f'    {SKIP_LINE}{COMMENT}\n')
                else:
                    new_test.insert(test_index, '\n')
                    new_test.insert(test_index, f'    {SKIP_LINE}{COMMENT}\n')
            seen_skip = False
            test_index = len(new_test)
            last_skip_check = None
            seen_other = False
        elif SKIP_LINE in line:
            seen_skip = True
        elif line.startswith('    if (builtin.zig_backend ==') and 'return error.SkipZigTest' in line and not seen_other:
            last_skip_check = len(new_test)
        else:
            seen_other = True

    test = new_test
    new_test = []

    test_path = os.path.join(tmpdir, 'test.zig')

    current = start_test
    for i, line in enumerate(test):
        if line.startswith('test'):
            # Cheekily strip out the text from the quotes
            name = line[len('test "') : -len('" {\n')]
        elif SKIP_LINE in line and 'flaky' not in line:
            if COMMENT in line:
                if not args.recheck:
                    continue # Skip adding this line

            current += 1

            test_without_check = test[:]
            del test_without_check[i]

            with open(test_path, 'w') as f:
                f.writelines(test_without_check)

            result = subprocess.run([
                args.compiler,
                'test',
                test_path,
                '--test-runner',
                os.path.join(basedir, 'src', 'test_runner.zig'),
                '-fno-compiler-rt',
                '-target',
                'spirv64-opencl-gnu',
                '-mcpu',
                'generic+Int64+Int16+Int8+Float64+Float16',
                '-fno-llvm',
                '--test-cmd',
                os.path.join(basedir, 'zig-out', 'bin', 'zig-spirv-executor'),
                '--test-cmd-bin',
            ], capture_output=True)
            if result.returncode == 0:
                print(f'[{current}/{total}] PASS {name}')
                continue # Skip adding the line
            else:
                stderr = result.stderr.decode('utf-8')
                if 'panic: reached unreachable code' in stderr:
                    error = 'unreachable'
                elif 'panic: index out of bounds' in stderr:
                    error = 'index out of bounds'
                elif 'panic: ' in stderr:
                    error = 'panic'
                elif 'Segmentation fault' in stderr:
                    error = 'segfault'
                elif '... FAIL (' in stderr:
                    error = 'test failure'
                elif 'has no member named \'fd_t\'' in stderr:
                    error = 'uses expectEqualSlices'
                elif 'Floating point width of ' in stderr:
                    error = 'uses f128/f80 float'
                elif 'BuildProgramFailure' in stderr:
                    error = 'backend compilation error'
                elif 'error: validation failed' in stderr:
                    error = 'validation failure'
                elif 'cannot call function pointers' in stderr:
                    error = 'uses function pointers'
                else:
                    tags = []
                    todos = []
                    for ln in stderr.split('\n'):
                        if 'TODO (SPIR-V): implement AIR tag' in ln:
                            tags.append(ln.split(' ')[-1])
                        elif 'TODO (SPIR-V): ' in ln:
                            todos.append(ln.split('TODO (SPIR-V): ')[1])
                        elif 'TODO: ' in ln:
                            todos.append(ln.split('TODO: ')[1])
                    if len(tags) != 0:
                        error = 'missing air tags ' + ', '.join(tags)
                    elif len(todos) != 0:
                        error = 'todo ' + ', '.join(todos)
                    else:
                        error = 'unknown'
                        error = stderr

                print(f'[{current}/{total}] FAIL {name} ({error})')

        new_test.append(line)

    for i in reversed(range(len(new_test))):
        if new_test[i].startswith('test') and new_test[i + 1].strip() == '':
            del new_test[i + 1]

    new_test = [line.replace(COMMENT, '') for line in new_test]
    with open(path, 'w') as f:
        f.writelines(new_test)

    subprocess.run([args.compiler, 'fmt', path], capture_output=True)

todo = {}
total_todo = 0
with tempfile.TemporaryDirectory() as tmpdir:
    if os.path.isfile(args.test):
        tests = scan_todo(args.test)
        todo[args.test] = tests
        total_todo += tests
    else:
        for subdir, dirs, files in os.walk(args.test):
            for path in files:
                path = os.path.join(subdir, path)
                tests = scan_todo(path)
                todo[path] = tests
                total_todo += tests

if args.todo:
    x = sorted(todo.items(), key=lambda x: x[1])
    for k, v in x:
        if v > 0:
            print(v, k)
else:
    current_test = 0
    with tempfile.TemporaryDirectory() as tmpdir:
        if os.path.isfile(args.test):
            update_test(tmpdir, args.test, current_test, total_todo)
        else:
            for subdir, dirs, files in os.walk(args.test):
                for path in files:
                    path = os.path.join(subdir, path)
                    if todo[path] != 0:
                        print(f'updating {path}')
                        update_test(tmpdir, path, current_test, total_todo)
                        current_test += todo[path]
